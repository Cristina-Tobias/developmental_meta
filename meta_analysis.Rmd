---
title: "A systematic review of short-term and working memory abilities in children with intellectual disability; to what extent do the result support the delay or difference hypotheses? "
author: "Cris"
date: "Last Updated: `r format(Sys.time(), '%d, %B, %Y at %H:%M')`"
output: rmdformats::readthedown
---

```{r import libraries, include=FALSE, warning=FALSE}
library(metafor)
library(readxl)
library(janitor)
library(reshape)
library(metafor)
library(metaviz)
library(readr)
library(ggplot2)
library(ggthemes)
library(patchwork)
library(TOSTER)
library(dplyr)
library(tidyr)
library(devtools)
library(ggrepel)
#devtools::install_github("MathiasHarrer/dmetar")
library(dmetar)
library(naniar)
library(skimr)
library(psych)
```

```{r create visualization functions from dsquintana, include=FALSE, warning=FALSE}

ma_pipe_sei <-
  function(dat,
           true_effect,
           rep_upper,
           rep_lower,
           analysis_title,
           plot = TRUE) {
#    dat <- read.csv(dat) # Read the file 
    res <- rma(yi,
               sei = sei,
               data = dat,
               method = "DL") # Perform a meta-analysis
    sunset <-  viz_sunset(
      x = dat[, c("yi", "sei")],
      contours = FALSE,
      true_effect = true_effect,
      power_contours = "continuous"
    ) # Create sunset plot
    dat[["power_observed"]] <-
      (1 - stats::pnorm(stats::qnorm(1 - 0.05 / 2) * dat[["sei"]],
                        abs(true_effect), dat[["sei"]])) +
      stats::pnorm(stats::qnorm(0.05 / 2) *
                     dat[["sei"]], abs(true_effect),
                   dat[["sei"]]) # Calculate power for each study
    dat[["power_e33"]] <-
      (1 - stats::pnorm(stats::qnorm(1 - 0.05 / 2) * dat[["sei"]],
                        abs(0.33), dat[["sei"]])) +
      stats::pnorm(stats::qnorm(0.05 / 2) *
                     dat[["sei"]], abs(0.33),
                   dat[["sei"]]) # Calculate power for each study for an effect of 0.33
    dat[["power_e66"]] <-
      (1 - stats::pnorm(stats::qnorm(1 - 0.05 / 2) * dat[["sei"]],
                        abs(0.66), dat[["sei"]])) +
      stats::pnorm(stats::qnorm(0.05 / 2) *
                     dat[["sei"]], abs(0.66),
                   dat[["sei"]]) # Calculate power for each study for an effect of 0.66
    power_median_dat <- data.frame(observed=numeric(1),e33=numeric(1),e66=numeric(1))
    power_median_dat[["observed"]] <- median(dat[["power_observed"]])
    power_median_dat[["e33"]] <- median(dat[["power_e33"]])
    power_median_dat[["e66"]] <- median(dat[["power_e66"]])
    power_median_dat <- as.data.frame(power_median_dat)
    power_median_dat <- mutate(power_median_dat, 
                               analysis = analysis_title) # Calculate median power
    rep_se <-
      ((rep_upper) - (rep_lower)) / (2 * 1.96) # Calculate SE for the summary effect
    sink("/dev/null")
    et <- TOSTmeta(
      ES = true_effect,
      se = rep_se,
      low_eqbound_d = -0.2,
      high_eqbound_d = 0.2,
      plot = TRUE
    ) # Perform an equivalence test
    # et <- data.frame(matrix(unlist(et), nrow=length(et), byrow=TRUE))
    et <- as.data.frame(et[-13])
    et <- mutate(et, Analysis = analysis_title) # Calculate median power
    sink()
    if (plot) {
      effect_size <- et$ES
      et <- as.data.frame(et)
      et_plot <-
        ggplot(et,
               aes(
                 x = "",
                 y = ES,
                 ymin = low_eqbound_d,
                 ymax = high_eqbound_d
               )) +
        geom_hline(aes(yintercept = 0), linetype = 'solid', size = 0.5) +
        geom_linerange(size = 5,
                       colour = "#00AFBB",
                       alpha = 0.5) +
        annotate(
          geom = "point",
          x = "",
          y = effect_size,
          color = "black",
          shape = 18,
          size = 4
        ) +
        theme(axis.text.x = element_text(size = 8)) +
        coord_flip() +
        theme_minimal() +
        theme(strip.text = element_text(
          size = 8,
          face = "bold",
          angle = 90
        )) +
        theme(strip.background = element_rect(colour = "black", fill = "white")) +
        theme(axis.title.y = element_text(face = "bold", size = 12)) +
        theme(axis.title.x = element_text(face = "bold", size = 12)) +
        theme(axis.title.y = element_blank()) +
        ylab(expression("Effect size"))
      et_plot <-
        et_plot + geom_linerange(aes(ymin = UL_CI_ZTEST, ymax = LL_CI_ZTEST), size = 0.5)
      et_plot <-
        et_plot + geom_linerange(aes(ymin = UL_CI_TOST, ymax = LL_CI_TOST),
                                 size = 1.5,
                                 colour = "black")
      et_plot # Creates an equivalence test plot
    }
    
    value <- list(
      res = res,
      dat = dat,
      power_median_dat = power_median_dat,
      sunset = sunset,
      et = et,
      et_plot = et_plot
    ) # Create a list of output objects
    attr(value, "class") <- "ma_pipe_sei"
    value
  }


# This function takes equivalence test results from the first function to create an equivalence test forest plot

combine_et <-
  function(dat){
    et_plot_combine <-
      ggplot(dat,
             aes(
               x = reorder(Analysis, -ES),
               y = ES,
               ymin = -0.6,
               ymax = 0.6
             )) +
      geom_rect(xmin = -Inf, ymin = -0.1, xmax = Inf, ymax = 0.1,
                fill = "#00AFBB", alpha = 0.2) +
      geom_rect(xmin = -Inf, ymin = -0.2, xmax = Inf, ymax = 0.2,
                fill = "#00AFBB", alpha = 0.1) +
      geom_rect(xmin = -Inf, ymin = -0.5, xmax = Inf, ymax = 0.5,
                fill = "#00AFBB", alpha = 0.05) +
      geom_point(color = "black",
                 shape = 18,
                 size = 4) +
      theme(axis.text.x = element_text(size = 8)) +
      coord_flip() +
      theme_minimal() +
      theme(strip.text = element_text(
        size = 8,
        face = "bold",
        angle = 90
      )) +
      theme(strip.background = element_rect(colour = "black", fill = "white")) +
      theme(axis.title.y = element_text(face = "bold", size = 12)) +
      theme(axis.title.x = element_text(face = "bold", size = 12)) +
      theme(axis.title.y = element_blank()) +
      ylab(expression("Effect size"))
    et_plot_combine <-
      et_plot_combine + geom_linerange(aes(ymin = UL_CI_ZTEST, ymax = LL_CI_ZTEST), size = 0.5)
    et_plot_combine <-
      et_plot_combine + geom_linerange(aes(ymin = UL_CI_TOST, ymax = LL_CI_TOST),
                                       size = 1.5,
                                       colour = "black")
    et_plot_combine <-
      et_plot_combine + scale_y_continuous(breaks=c(-.5, -.20,-.1, 0, .1, 0.2, 0.5))
    et_plot_combine <-
      et_plot_combine + geom_hline(yintercept=0, linetype="dashed", color = "black")
    et_plot_combine # Creates an equivalence test plot
  }

```

```{r data reading and cleaning, include=FALSE, warning=FALSE}
data <- read_excel("datafile_broader_ef.xlsx")
data <- clean_names(data)
data <- data[!duplicated(data), ]
# colnames(data)[13] <- 'yi'

columns_of_interest <- c('study_year', 'n_id','age_id', 'mean_ma_id', 
                         'sd_ma_id', 'iq_id', 'n_magroup', 'age_magroup',
                         'mean_ma_magroup', 'iq_magroup',
                         'mean_id', 'mean_magroup', 'sd_id','sd_magroup')
  # c('year', 'sample_size_id_n', 'chronological_age_id_m', 'chronological_age_id_sd',
  #                        'mental_age_id_m', 'mental_age_id_sd',
  #                        'iq_id_m', 'iq_id_sd',
  #                        'sample_size_controls_n',  'chronological_age_controls_m', 'chronological_age_controls_sd',
  #                        'mental_age_controls_m', 'mental_age_controls_sd',
  #                        'iq_controls_m', 'iq_controls_sd', 
  #                        'task_1_mean_control_group','task_1_mean_id_group', 'task_1_sd_control_group',
  #                        'task_1_sd_id_group', 'task_1_n_control_group','task_1_n_id_group',
  #                        'task_2_mean_control_group','task_2_mean_id_group', 'task_2_sd_control_group',
  #                        'task_2_sd_id_group', 'task_2_n_control_group','task_2_n_id_group'
  #                        )

data[, columns_of_interest] <- lapply(data[, columns_of_interest], as.numeric)

stats_test <- escalc(
    m2i = mean_magroup,
    m1i = mean_id,
    sd2i = sd_magroup,
    sd1i = sd_id,
    n2i = n_magroup,
    n1i = n_id,
    data = data,
    append = TRUE,
    measure = 'SMD1H'
  )
stats_test$sei <- sqrt(stats_test$vi)
# stats_test_2 <- escalc(
#     m2i = task_2_mean_control_group,
#     m1i = task_2_mean_id_group,
#     sd2i = task_2_sd_control_group,
#     sd1i = task_2_sd_id_group,
#     n2i = task_2_n_control_group,
#     n1i = task_2_n_id_group,
#     data = data,
#     append = TRUE,
#     measure = 'SMD1H'
#   )

ma_model <- rma(yi, vi, data = stats_test)
# ma_model_2 <- rma(yi, vi, data = stats_test_2)
```

## Aim

The aim of the study is to investigate if short-term and working memory abilities exhibit a developmentally delayed or developmentally different pattern in children with ID. This will be done by an overall analysis and subgroup analyses based on type of memory (short-term or working memory), aetiology of ID (familial or organic). In addition, the overall analysis will also be repeated with level of IQ as a moderator.

### Research questions

1.  Do short-term and working memory abilities exhibit a developmentally delayed or developmentally different pattern in children with ID (compared to mental age matched groups)? 1.1 Is this pattern moderated by origin of ID (familial and organic) or level of IQ?
2.  Do origin (familial and organic) of ID or level of IQ moderate whether STM and WM performance are delayed or different?

### Hypotheses

1.  The STM delay hypothesis will be supported if STM performance of participants with ID will not differ significantly from that of the mental age-matched group

2.  The WM delay hypothesis will be supported if WM performance of participants with ID will not differ significantly from that of the mental age-matched group

3.  The STM difference hypothesis will be supported if STM performance of participants with ID will differ significantly from that of the mental age-matched group. We expect that the difference may occur in any direction.

4.  The WM difference hypothesis will be supported if WM performance of participants with ID will differ significantly from that of the mental age-matched group. We expect that the difference may occur in any direction.

## Methods
### Data extraction

We extracted data from stuff

### Statistical analysis

We tested the difference in performance moderating for type of task and also for type of ID

### Equivalence testing
Yes

## Results

### Descriptives
We conducted and reported this systematic review according to NIRO-SR guidelines for conducting and reporting systematic reviews of non-intervention research (REF). See table X for descriptives of the obtained studies.

```{r data descriptives, warning=FALSE}
skim(data[, columns_of_interest])
```

For both groups, we extracted the iq, number of participants, mean and sd of the performance in the tasks, and the mean and sd of the chronological and mental age. There was a total of an 8.4% of missing data with the iq of the control group missing 51% of the times
```{r descriptives, warning=FALSE}
vis_miss(data[,columns_of_interest])
```

### Statistical analysis

We are performing a multilevel analysis 
```{r equivalence test}
overall_3_level <- rma.mv(yi, vi, random = list(~ 1 | effectsize_id, ~1 | study_id), 
                          tdist = TRUE, data = stats_test)
 
 
#two-level model without within-study variance (to estimate the between-study variance)
modelnovar2 <- rma.mv(yi, vi, random = list(~ 1 | effectsize_id, ~1 | study_id), 
                      sigma2 = c(0,NA), tdist = TRUE, data = stats_test)
 
anova(overall_3_level,modelnovar2)
 
#build a two-level model without between-study variance (to estimate the within-study variance);
 
modelnovar3 <- rma.mv(yi, vi, random = list(~ 1 | effectsize_id, ~ 1 | study_id), 
                      sigma2 = c(NA,0), tdist = TRUE, data = stats_test)
 
anova(overall_3_level,modelnovar3)
```

Moderating type of ID
```{r tests type of ID}
res_DS <- rma(yi, vi, data=stats_test, subset=group_id=="DS")
res_NSID <- rma(yi, vi, data=stats_test, subset=group_id=="NSID")
res_FXS <- rma(yi, vi, data=stats_test, subset=group_id=="FXS")
res_WS <- rma(yi, vi, data=stats_test, subset=group_id=="WS")

dat.comp <- data.frame(alloc    = c("DS", "NSID", "FXS", "WS"), 
                       estimate = c(coef(res_DS), coef(res_NSID), coef(res_FXS), coef(res_WS)), 
                       stderror = c(res_DS$se, res_NSID$se, res_FXS$se, res_WS$se),
                       tau2     = c(res_DS$tau2, res_NSID$tau2, res_FXS$tau2, res_WS$tau2))
dfround(dat.comp, 3)

rma(estimate, sei=stderror, mods = ~ alloc, method="FE", data=dat.comp, digits=3)


```

```{r plots type of ID, , fig.dim = c(15, 20)}
id_tests <- t(data.frame(DS = c(res_DS$b, res_DS$se,res_DS$ci.lb, res_DS$ci.ub),
                         NSID = c(res_NSID$b, res_NSID$se,res_NSID$ci.lb, res_NSID$ci.ub),
                         FXS = c(res_FXS$b, res_FXS$se,res_FXS$ci.lb, res_FXS$ci.ub),
                         WS = c(res_WS$b, res_WS$se,res_WS$ci.lb, res_WS$ci.ub),
                         row.names = c('b', 'se', 'ci.lb', 'ci.ub')))
for (id in c('DS', 'NSID', 'FXS', 'WS')){
  df <- stats_test[stats_test$group_id == id, c('cite', 'yi', 'sei', 'n_magroup', 'n_id')]
  
  # Compute confidence intervals and format labels
  
  df$cite <- paste0(df$cite, '.', ave(df$cite, df$cite, FUN = seq_along))
  df <- df %>%
    mutate(
      lower = yi - 1.96 * sei,  
      upper = yi + 1.96 * sei,  
      ci_text = paste0(round(yi,2), "  [", round(lower, 2), ", ", round(upper, 2), "]")
    )
  FE_model <- paste0('F.E Model for ', id, ' group')
  df <- df %>%
    arrange(yi)
  df <- rbind(df, c(FE_model, id_tests[id,'b'], id_tests[id,'se'], '','', 
                    id_tests[id,'ci.lb'], id_tests[id,'ci.ub'], 
                    paste0(round(id_tests[id,'b'],2), 
                           "  [", round(id_tests[id,'ci.lb'], 2), ", ", 
                           round(id_tests[id,'ci.ub'], 2), "]")))
  df[, c('yi','sei', 'lower', 'upper')] <- lapply(df[, c('yi','sei', 'lower', 'upper')], as.numeric)
  df$desired_order <- seq(dim(df)[1],1)
  p_right <- ggplot(df, aes(y = reorder(cite, desired_order))) +
    geom_point(aes(x=yi), size = 3, shape=15, color = "darkred") +  
    geom_errorbarh(aes(xmin = lower, xmax = upper), height = 0.2, color = "grey") +  
    labs(
      x = "Effect Size (Cohen's d)",
      y = "Study",
      caption = "Error bars represent 95% confidence intervals"
    )   + theme(axis.line.y = element_blank(),
                axis.ticks.y= element_blank(),
                axis.text.y= element_blank(),
                axis.title.y= element_blank(),
                panel.background = element_rect(fill = "white"
                )) + coord_cartesian(xlim = c(min(df$lower), max(df$upper)), ylim = c(0,dim(df)[1] + 1))
  p_left <- ggplot(df, aes(y = reorder(cite, desired_order))) + labs(x = '') +
    geom_text(aes(x = 0, label = cite), hjust = 0, fontface = "bold") +
    annotate(geom="text", x=0.3, y=dim(df)[1] + 1, label="Study", fontface = "bold") +
    geom_text(aes(x = 0.8, label = n_id), hjust = 0) +
    annotate(geom="text", x=0.8, y=dim(df)[1] + 1, label="N (ID)", fontface = "bold") +
    geom_text(aes(x = 1, label = n_magroup), hjust = 0) +
    annotate(geom="text", x=1, y=dim(df)[1] + 1, label="N (Control)", fontface = "bold") +
    geom_text(
      aes(x = 1.3, label = ci_text),
      hjust = 0
    ) +
    annotate(geom="text", x=1.4, y=dim(df)[1] + 1, label="E.F [95% CI]", fontface = "bold") +
    theme_void() +
    coord_cartesian(xlim = c(0, 2), ylim = c(0,dim(df)[1] + 1))
  
  layout <- c(
    area(t = 0, l = 0, b = dim(df)[1], r = 5), 
    area(t = 0, l = 6, b = dim(df)[1], r = 8) 
  )
  print(p_left + p_right + plot_layout(design = layout))
  Sys.sleep(2)
}


```

Moderating type of executive function
```{r tests type of EF}
res_inhibition <- rma(yi, vi, data=stats_test, subset=ef_type=="inhibition")
res_updating <- rma(yi, vi, data=stats_test, subset=ef_type=="updating")
res_shifting <- rma(yi, vi, data=stats_test, subset=ef_type=="shifting")
res_fluency <- rma(yi, vi, data=stats_test, subset=ef_type=="fluency")
res_attention <- rma(yi, vi, data=stats_test, subset=ef_type=="attention")
res_other <- rma(yi, vi, data=stats_test, subset=ef_type=="other")

dat.comp <- data.frame(alloc    = c("Inhibition", "Updating", "Shifting", "Fluency", 'Attention', 'Other'), 
                       estimate = c(coef(res_inhibition), coef(res_updating), coef(res_shifting), coef(res_fluency), coef(res_attention), coef(res_other)), 
                       stderror = c(res_inhibition$se, res_updating$se, res_shifting$se, res_fluency$se, res_attention$se, res_other$se),
                       tau2     = c(res_inhibition$tau2, res_updating$tau2, res_shifting$tau2, res_fluency$tau2, res_attention$tau2, res_other$tau2))
dfround(dat.comp, 3)

rma(estimate, sei=stderror, mods = ~ alloc, method="FE", data=dat.comp, digits=3)

```
```{r plots type of EF, fig.dim = c(15, 20)}
id_tests <- t(data.frame(inhibition = c(res_inhibition$b, res_inhibition$se,res_inhibition$ci.lb, res_inhibition$ci.ub),
                         updating = c(res_updating$b, res_updating$se,res_updating$ci.lb, res_updating$ci.ub),
                         shifting = c(res_shifting$b, res_shifting$se,res_shifting$ci.lb, res_shifting$ci.ub),
                         fluency = c(res_fluency$b, res_fluency$se,res_fluency$ci.lb, res_fluency$ci.ub),
                         attention = c(res_attention$b, res_attention$se,res_attention$ci.lb, res_attention$ci.ub),
                         other = c(res_other$b, res_other$se,res_other$ci.lb, res_other$ci.ub),
                         
                         row.names = c('b', 'se', 'ci.lb', 'ci.ub')))
for (id in c("inhibition", "updating", "shifting", "fluency", 'attention', 'other')){
  df <- stats_test[stats_test$ef_type == id, c('cite', 'yi', 'sei', 'n_magroup', 'n_id')]
  
  # Compute confidence intervals and format labels
  
  df$cite <- paste0(df$cite, '.', ave(df$cite, df$cite, FUN = seq_along))
  df <- df %>%
    mutate(
      lower = yi - 1.96 * sei,  
      upper = yi + 1.96 * sei,  
      ci_text = paste0(round(yi,2), "  [", round(lower, 2), ", ", round(upper, 2), "]")
    )
  FE_model <- paste0('F.E Model for ', id, ' group')
  df <- df %>%
    arrange(yi)
  df <- rbind(df, c(FE_model, id_tests[id,'b'], id_tests[id,'se'], '','', 
                    id_tests[id,'ci.lb'], id_tests[id,'ci.ub'], 
                    paste0(round(id_tests[id,'b'],2), 
                           "  [", round(id_tests[id,'ci.lb'], 2), ", ", 
                           round(id_tests[id,'ci.ub'], 2), "]")))
  df[, c('yi','sei', 'lower', 'upper')] <- lapply(df[, c('yi','sei', 'lower', 'upper')], as.numeric)
  df$desired_order <- seq(dim(df)[1],1)
  p_right <- ggplot(df, aes(y = reorder(cite, desired_order))) +
    geom_point(aes(x=yi), size = 3, shape=15, color = "darkred") +  
    geom_errorbarh(aes(xmin = lower, xmax = upper), height = 0.2, color = "grey") +  
    labs(
      x = "Effect Size (Cohen's d)",
      y = "Study",
      caption = "Error bars represent 95% confidence intervals"
    )   + theme(axis.line.y = element_blank(),
                axis.ticks.y= element_blank(),
                axis.text.y= element_blank(),
                axis.title.y= element_blank(),
                panel.background = element_rect(fill = "white"
                )) + coord_cartesian(xlim = c(min(df$lower), max(df$upper)), ylim = c(0,dim(df)[1] + 1))
  p_left <- ggplot(df, aes(y = reorder(cite, desired_order))) + labs(x = '') +
    geom_text(aes(x = 0, label = cite), hjust = 0, fontface = "bold") +
    annotate(geom="text", x=0.3, y=dim(df)[1] + 1, label="Study", fontface = "bold") +
    geom_text(aes(x = 0.8, label = n_id), hjust = 0) +
    annotate(geom="text", x=0.8, y=dim(df)[1] + 1, label="N (ID)", fontface = "bold") +
    geom_text(aes(x = 1, label = n_magroup), hjust = 0) +
    annotate(geom="text", x=1, y=dim(df)[1] + 1, label="N (Control)", fontface = "bold") +
    geom_text(
      aes(x = 1.3, label = ci_text),
      hjust = 0
    ) +
    annotate(geom="text", x=1.4, y=dim(df)[1] + 1, label="E.F [95% CI]", fontface = "bold") +
    theme_void() +
    coord_cartesian(xlim = c(0, 2), ylim = c(0,dim(df)[1] + 1))
  
  layout <- c(
    area(t = 0, l = 0, b = dim(df)[1], r = 5), 
    area(t = 0, l = 6, b = dim(df)[1], r = 8) 
  )
  print(p_left + p_right + plot_layout(design = layout))
  Sys.sleep(2)
}


```
### Equivalence testing
The studies looked at different types of executive functions (CHANGE THIS LATER TO SUIT OUR OWN ANALYSIS). In the next table you can see the extracted descriptives separated by executive function

```{r descriptives ef, warning=FALSE}
describeBy(data[,columns_of_interest], data$ef_type)
```

Equivalence testing for the different types of tasks.

```{r equivalence test plots}

inhibition <- stats_test[stats_test$ef_type == 'inhibition',]
inhibition_model <- rma(yi, vi, data = inhibition)
inhibition_results <- ma_pipe_sei(
  inhibition,
  true_effect = inhibition_model$b,
  rep_lower = inhibition_model$ci.lb,
  rep_upper = inhibition_model$ci.ub,
  analysis_title = "inhibition tasks",
  plot = TRUE
)

inhibition_power_median_dat <- inhibition_results$power_median_dat
inhibition_power_median_dat$ES <- mean(inhibition$yi)
inhibition_et_dat <- inhibition_results$et

updating <- stats_test[stats_test$ef_type == 'updating',]
updating_model <- rma(yi, vi, data = updating)
updating_results <- ma_pipe_sei(
  updating,
  true_effect = updating_model$b,
  rep_lower = updating_model$ci.lb,
  rep_upper = updating_model$ci.ub,
  analysis_title = "updating tasks",
  plot = TRUE
)
updating_power_median_dat <- updating_results$power_median_dat
updating_power_median_dat$ES <- mean(updating$yi)
updating_et_dat <- updating_results$et

shifting <- stats_test[stats_test$ef_type == 'shifting',]
shifting_model <- rma(yi, vi, data = shifting)
shifting_results <- ma_pipe_sei(
  shifting,
  true_effect = shifting_model$b,
  rep_lower = shifting_model$ci.lb,
  rep_upper = shifting_model$ci.ub,
  analysis_title = "shifting tasks",
  plot = TRUE
)
shifting_power_median_dat <- shifting_results$power_median_dat
shifting_power_median_dat$ES <- mean(shifting$yi)
shifting_et_dat <- shifting_results$et

fluency <- stats_test[stats_test$ef_type == 'fluency',]
fluency_model <- rma(yi, vi, data = fluency)
fluency_results <- ma_pipe_sei(
  fluency,
  true_effect = fluency_model$b,
  rep_lower = fluency_model$ci.lb,
  rep_upper = fluency_model$ci.ub,
  analysis_title = "fluency tasks",
  plot = TRUE
)
fluency_power_median_dat <- fluency_results$power_median_dat
fluency_power_median_dat$ES <- mean(fluency$yi)
fluency_et_dat <- fluency_results$et

attention <- stats_test[stats_test$ef_type == 'attention',]
attention_model <- rma(yi, vi, data = attention)
attention_results <- ma_pipe_sei(
  attention,
  true_effect = attention_model$b,
  rep_lower = attention_model$ci.lb,
  rep_upper = attention_model$ci.ub,
  analysis_title = "attention tasks",
  plot = TRUE
)
attention_power_median_dat <- attention_results$power_median_dat
attention_power_median_dat$ES <- mean(attention$yi)
attention_et_dat <- attention_results$et


other <- stats_test[stats_test$ef_type == 'other',]
other_model <- rma(yi, vi, data = other)
other_results <- ma_pipe_sei(
  other,
  true_effect = other_model$b,
  rep_lower = other_model$ci.lb,
  rep_upper = other_model$ci.ub,
  analysis_title = "other tasks",
  plot = TRUE
)
other_power_median_dat <- other_results$power_median_dat
other_power_median_dat$ES <- mean(other$yi)
other_et_dat <- other_results$et

com1 <- rbind(inhibition_et_dat,
              updating_et_dat,
              shifting_et_dat,
              fluency_et_dat,
              attention_et_dat, 
              other_et_dat)
com1 <- combine_et(com1)
com1 <- com1 + ggtitle("Summary effect sizes and equivalence bounds") +
  theme(plot.title = element_text(hjust = 0.5))


# Create the meta-analysis power tile supplement 

power_med <- rbind(inhibition_power_median_dat,
              updating_power_median_dat,
              shifting_power_median_dat,
              fluency_power_median_dat,
              attention_power_median_dat, 
              other_power_median_dat)

power_med_long <- gather(power_med, effect, power, observed:e66, factor_key=TRUE)

tile <- ggplot(data = power_med_long, aes(x = effect, y = reorder(analysis, -ES),)) + 
  geom_tile(aes(fill = power)) + 
  coord_equal(ratio = 0.8) + 
  scale_fill_gradient(name = "Power", low = "#FDF0FF", high = "#E200FD") + theme_tufte(base_family="Helvetica")

tile <- tile + theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank())

tile <- tile + ggtitle("Median statistical power") +
  xlab("Effect size") +
  theme(plot.title = element_text(hjust = 0.5))

tile <- tile + scale_x_discrete(labels=c("observed" = "Observed \n effect", "e33" = "0.33",
                                         "e66" = "0.66"))
tile

# Combine the two plots
com1 + tile

```








